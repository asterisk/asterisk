/*
 * Asterisk -- An open source telephony toolkit.
 *
 * Copyright (C) 2012 - 2013, Digium, Inc.
 *
 * David M. Lee, II <dlee@digium.com>
 *
 * See http://www.asterisk.org for more information about
 * the Asterisk project. Please do not directly contact
 * any of the maintainers of this project for assistance;
 * the project provides a web site, mailing lists and IRC
 * channels for your use.
 *
 * This program is free software, distributed under the terms of
 * the GNU General Public License Version 2. See the LICENSE file
 * at the top of the source tree.
 */

/*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!!!!                               DO NOT EDIT                        !!!!!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * This file is generated by a mustache template. Please see the original
 * template in rest-api-templates/res_stasis_http_resource.c.mustache
 */

/*! \file
 *
 * \brief WebSocket resource
 *
 * \author David M. Lee, II <dlee@digium.com>
 */

/*** MODULEINFO
	<support_level>core</support_level>
 ***/

#include "asterisk.h"

ASTERISK_FILE_VERSION(__FILE__, "$Revision$")

#include "asterisk/module.h"
#include "asterisk/json.h"
#include "stasis_json/resource_events.h"
#include "asterisk/stasis_channels.h"
#include "asterisk/stasis_bridging.h"

struct ast_json *stasis_json_event_channel_userevent_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "eventname");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_userevent", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_bridge_created_create(
	struct ast_bridge_snapshot *bridge_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(bridge_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"bridge", ast_bridge_snapshot_to_json(bridge_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "bridge_created", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_playback_finished_create(
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;

	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "playback");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "playback_finished", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_snapshot_create(
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_snapshot", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_caller_id_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "caller_presentation_txt");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	validator = ast_json_object_get(blob, "caller_presentation");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_caller_id", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_playback_started_create(
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;

	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "playback");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "playback_started", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_bridge_destroyed_create(
	struct ast_bridge_snapshot *bridge_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(bridge_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"bridge", ast_bridge_snapshot_to_json(bridge_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "bridge_destroyed", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_application_replaced_create(
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;

	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "application");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "application_replaced", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_destroyed_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "cause");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	validator = ast_json_object_get(blob, "cause_txt");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_destroyed", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_varset_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "variable");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	validator = ast_json_object_get(blob, "value");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_varset", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_left_bridge_create(
	struct ast_bridge_snapshot *bridge_snapshot,
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(bridge_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"bridge", ast_bridge_snapshot_to_json(bridge_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_left_bridge", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_created_create(
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_created", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_stasis_start_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "args");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "stasis_start", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_dialplan_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "application");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	validator = ast_json_object_get(blob, "application_data");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_dialplan", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_state_change_create(
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_state_change", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_hangup_request_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "soft");
	if (validator) {
		/* do validation? XXX */
	}

	validator = ast_json_object_get(blob, "cause");
	if (validator) {
		/* do validation? XXX */
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_hangup_request", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_entered_bridge_create(
	struct ast_bridge_snapshot *bridge_snapshot,
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(bridge_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"bridge", ast_bridge_snapshot_to_json(bridge_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_entered_bridge", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_channel_dtmf_received_create(
	struct ast_channel_snapshot *channel_snapshot,
	struct ast_json *blob
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	struct ast_json *validator;
	int ret;

	ast_assert(channel_snapshot != NULL);
	ast_assert(blob != NULL);
	ast_assert(ast_json_object_get(blob, "channel") == NULL);
	ast_assert(ast_json_object_get(blob, "type") == NULL);

	validator = ast_json_object_get(blob, "digit");
	if (validator) {
		/* do validation? XXX */
	} else {
		/* fail message generation if the required parameter doesn't exist */
		return NULL;
	}

	event = ast_json_deep_copy(blob);
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "channel_dtmf_received", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

struct ast_json *stasis_json_event_stasis_end_create(
	struct ast_channel_snapshot *channel_snapshot
	)
{
	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
	RAII_VAR(struct ast_json *, event, NULL, ast_json_unref);
	int ret;

	ast_assert(channel_snapshot != NULL);

	event = ast_json_object_create();
	if (!event) {
		return NULL;
	}

	ret = ast_json_object_set(event,
		"channel", ast_channel_snapshot_to_json(channel_snapshot));
	if (ret) {
		return NULL;
	}

	message = ast_json_pack("{s: o}", "stasis_end", ast_json_ref(event));
	if (!message) {
		return NULL;
	}

	return ast_json_ref(message);
}

static int load_module(void)
{
	return 0;
}

static int unload_module(void)
{
	return 0;
}

AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER,
	"Stasis JSON Generators and Validators - WebSocket resource",
	.load = load_module,
	.unload = unload_module,
	.load_pri = AST_MODPRI_DEFAULT,
	);
